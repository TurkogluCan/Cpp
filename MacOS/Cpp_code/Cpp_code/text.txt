




/* Bu ornekte "int &func()" fonksiyonu referans donusu olan bir fonksiyondur ve static int olan g'yi doner. Nesneyi referans olarak doner.
   C++'da;q
   "Tur &func(...)" prototipindeki bir fonksiyona "func() = ..." seklinde yapilan cagri ifadesi "lvalue expression" sol deger 
   ifadesidir.
   "func() = ..."  gibi bir atama durumu da mumkundur. Burada func donusu g'nin referansidir ve g'nin referansina
   bir deger ataniyor diye dusunulmelidir.
   -> func() = 45;    veya    int &r = g;
                              r = 45;
   
   -> Tur &r = func();
*/

/*
    ---------------------------------------------------- R E F E R A N C E ----------------------------------------------------
    Referanslar C dilinde XXX * const ptr; ifadesine benzetilebilir. (XXX değişken tipidir, örn int)

    1* Referanslara ilk deger vermek mecburi.
    -> int ival = 10;
    -> int &r   = ival;                         // Lvalue expression
       int &r{ival};
       int &r(ival);

    2* Referanslara ilk deger veren sol taraf degeri ile reference turu ayni olmak zorunda.
    -> int ival = 10;
    -> double &r   = ival;                       ❌ - ERROR                  
       double &r   = (double&)ival;              ✔  - OK 
       int &r      = ival;                       ✔  - OK
    
    3* Bir rvalue expression bir lvalue referansa ilk deger veremez. 
    -> int x     = 10;
       int &r    = x + 10;                       ❌ - ERROR 
       double &r = (double)ival;                 ❌ - ERROR 

    4* Bir referans bir nesneye baglanir, sonrasinda baska bir nesneye baglanamaz(Pointer Ref haric). Yani gosterdigi adres sonradan degistirilemez(const* ptr gibi)
    -> int x     = 10;
       int &r    = x + 10;                       ❌ - ERROR
       double &r = (double)ival;                 ❌ - ERROR

    5* Bir pointer kendisine referans alabilir.
    -> int x     = 10;           (int x)
       int *ptr  = &x;           (int * ptr)  = (int *)x 
       int *&rp  = ptr;          (int * &rp)  = ptr
                   
    6* Bir dizi kendisine referans alabilir.
    -> int a[5]      = {0,1,2,3,4};  
       int (&ra)[5]  = a;           
                        
    7* Referans kullaniminda pointerda oldugu gibi NULL pointer semantigi yoktur.

    8* Elemanlari referans olan bir referans dizisi olamaz.

    9* "Tur &func(...)" prototipindeki bir fonksiyona "func() = ..." seklinde yapilan cagri ifadesi "lvalue expression" sol deger 
        ifadesidir. Bu sayede deger atanabilmektedir.
        func(...) fonksiyonu nesneyi referans olarak doner. Bu yuzden referansa ilk deger vermede de kullanılabilmektedir.
        
        -> func() = 10;
        -> Tur &r = func();
    
    10* Referans ile pointer kullanmak assembly kod acisindan neredeyse aynidir. Derleyici icin neredeyse bir fark yoktur.
    
    11* Referanslarda null durumu yoktur.
 
    12* Elemanları nesne referansı(adresi) olan pointer dizisi olabilirken, referans dizisi
 
 
    ---------------------------------------------------- R E F E R A N C E  ve  C O N S T ---------------------------------------
    

    1* Referance'lardki "Tur * const ptr" karsiligi      ❌  (tur * const ptr)
    -> int x = 10;
       int &const r = x;
       Bu kullanim dogru bir kullanim degildir. Cunku referanslarin gosterdigi nesne zaten degistirilemez, baska bir nesnenin yerine gecemez. 
       Dogustan kenidisi const'tur.
       Derleyici Syntax hatasi vermeyebilir fakat uyari verir. 

    2* Referance'lardki "const Tur *ptr" karsiligi        ✔  (const tur *ptr)
    -> int x = 10;
       const int &r = x;
    -> const Tur *foo(...)
       Bu kullanimla birlikte r'nin gosterdigi x yalnizca salt okunabilir olarak kullanilabilinecektir. x'in degeri degistirilemez.




    ---------------------------------------------------- N U L L ----------------------------------------------------------------
    C'de "NULL"  bir makrodur. Tanimi;
    #define NULL (void *)0
    -> int *ptr = NULL;
       ptr = 0;
    C++'de nullptr vardır.  nullptr bir sabittir ve bir turu vardır. Bu turun ismi nullptr_t'dir.
    typedef decltype(nullptr) nullptr_t; 
    -> int *ptr = nullptr_t;
 
    Referanslarda null durumu yoktur.


******************************************************************************************************************************************/

/* Const Referans
 *************************************
 
 Referans tanımlamanırken normalde sabit bir değer atanamaz, l-value bir nesne atanabilir. Fakat const referans nesnelere sabit değerlerin atanması da geçerlidir.
 
 -> const int &cr1 = 10;
 bildirisinde derleyici tarafından geçici bir
 nesne oluşturulur ve const kabul edilir. Bu yüzden bu ifade geçerlidir.
 *************************************
*/
 #include <iostream>


 void func(const int &cr2)
 {
     
 }


 int main()
 {
           int &r1  = 10;      // Bu ifade geçersizdir ❌
     func(r1);
     
     const int &cr1 = 10;      // Bu ifade geçerlidir ✅
     func(cr1);
     

 }





// ----------------------------------------------------------------------------------------------------------------------------------
// AUTO

#include <iostream>


double foo(){
    return 1.0;
};
int boo(int){
    return 10;
};


int main()
{
    // int h = 20
    const int cx = 20;
    auto h = cx;       // int h = 20
    
    // int y
    int  x = 10;
    auto y = x;
    
    // double z
    auto z = foo();
    
    // int q = 0;
    auto q = 0;
    
    // int a, referanslık düşer
    {
        int xx = 10;
        int &rx = x;
        auto a = rx;
    }
    
    // int a, referanslık ve constluk  düşer
    {
        int xx = 10;
        const int &rx = x;
        auto a = rx;
    }
    
    // int *ax = a
    {
        int a[10];
        auto ax = a;
    }
    
    //  const int *ax = a, tur cikarimi yapilirken const a, array to pointer conversion ile array decay ile const int* turune donusecektir.
    {
        const int a[] = {1,2,3};
        auto ax = a;
    }
    
    //  int(*fp)(int) , function pointer
    {
        auto f = boo;
    }

    //  int &r = x, auto referans
    {
        int  x  = 10;
        auto &r = x;
    }
    
    //  const int &r = x, constluk dusmez
    {
        const int  cx  = 10;
        auto &r = cx;
    }
    
    //  int (&r)[3] = x, constluk dusmez
    {
        int a[3] = {1,2,3};
        auto &r = a;
    }
    
    
}

/* Type Deduction - Tur Cikarimi
 *************************************
 
 AAA(Almost Always auto)
 - auto ile yaratılan nesnenin ilk değer ataması zorunludur.
 - auto ilk değer atamasinda {} ifadesini kullanmak sorun olabilir.
 
 Reference collapsing:
 Eger icerisinde bir tane bile sol taraf referansı(&) varsa sol taraf referansına, yoksa sağ taraf(&&) referansına bağlanır
 - int &   &r   -> int  &r
 - int &   &&r  -> int  &r
 - int &&   &r  -> int  &r
 - int &&  &&r  -> int &&r
 *************************************
 */





// ----------------------------------------------------------------------------------------------------------------------------------
/* CONSTEXPR
 *************************************
 - Sabit ifadeler, derleyicinin koda bakarak doğrudan bir sabit elde ettiği ifadelere denir. Yani
   ifadenin değeri runtime değil compiler time'da bellidir.
 
 - *** CONSTEXPR fonksiyon; girdileri, içerisinde yapılan işlemler ve dönüşü sabit olan fonksiyonlara denir. Bu tip fonksiyonların
   içeriği sabit olduğu için fonksiyonun geri dönüş değeri de diğer sabitler gibi runtime'da değil de compiler time'da elde edilir.
 - *** constexpr fonksiyonların çıktıları compiler time'da elde edildiği için bu fonksiyonun içerisine yazılan kodlar gizlenemez. Eğer
   lib yapılmak istenirse veya fonksiyon başka dosyalardan çağırılacaksa başlık dosyasına yazılmalıdır ki derleyici compiler time'da sonucu üretebilsin.
   *** Bu yüzden CONSTEXPR FONKSİYONLARIN İÇERİĞİ KESİNLİKLE GİZLENEMEZ.
 - constexpr fonksiyonlar inline fonksiyonlardır.
 
 - constexpr belirteci ile yapılan tanımlamalar sabit olarak kabul edilir.
 - constexpr ile tanımlanan değişkenlerin kullanıldığı ifadeler de birer sabit ifadeleridir.
 
 *************************************
*/

// Include
#include <iostream>


// Func
constexpr int sum_square(int x, int y)
{
    return x*x + y*y;
}


//
int main()
{
    // Sabit ifadeler, dizi tanımlaması sırasında index constexpr ifadeler ile yapılmıştır. Const anahtar sözcüğü ile de geçerlidir.
    // Bu ifade C'de geçersizdir.
    {
        constexpr int x = 10;
        constexpr int y = 20;
        
        int a[x+y]{};   // Dogru
    }
    
    //** Const anahtar sözcüğü kullanarak sabit olmayan ifadelerle yapılan tanımlamanın sonucu da const değildir. Fakat hata da değildir.
    {
        int x = 10;
        int y = 20;
        const int b = x+y;
        int a[b]{};             // HATA
    }
    
    //** Constexpr anahtar sözcüğü kullanarak sabit olmayan ifadelerle yapılan tanımlama GEÇERSİZDİR.
    {
        int x = 10;
        int y = 20;
        constexpr int b = x+y;        // HATA
    }
    
    // Constexpr örnek ifade
    {
        const int x = 10;
        const int y = 20;
        constexpr int b = x*x + y*y;        // GEÇERLİ
    }
    
    // Constexpr örnek ifade
    {
        constexpr int x = 10;
        constexpr int y = 20;
        constexpr int b = x*x + y*y;        // GEÇERLİ
    }
    
    //** CONST vs CONSTEXPR
    //   constexpr anahtar sözcüğü kullanılarak yapılan ilk değer atamasında kullanılan fonksiyon mutlaka "constexpr fonksiyon" olmalıdır.
    //   Bu zorunluluk const için yoktur.
    {
        int foo();
        
        const int x = foo();          // GEÇERLİ

        constexpr int y = foo();      // HATA
    }
    
    //** CONSTEXPR fonksiyon, girdileri, içerisinde yapılan işlemler ve dönüşü sabit olan fonksiyonlara denir. Bu tip fonksiyonların
    // içeriği sabit olduğu için fonksiyonun geri dönüş değeri de diğer sabitler gibi runtime'da değil de compiler time'da elde edilir.
    // Eğer fonksiyon içerisinde sabitliği bozan ifadeler kullanılırsa hata verir ve geçersizdir.
    {
        const int a = 2;
        const int b = 3;

        constexpr int y = sum_square(a+5, b*2);   // GECERLİ, Derleyici için sabit bir ifadedir.
        int arr[sum_square(a+5, b*2)]{};          // Sabit bir ifade olduğu için dizinin boyutu da yapılabilir
    }
    
    //** CONSTEXPR fonksiyon, HATALI
    {
        int a = 2;
        int b = 3;

        constexpr int y = sum_square(a,b);   // HATALI, fonksiyon parametreleri sabit olmalı
    }
    
}



// CONSTEXPR --------------------------------------------------------------------------------

