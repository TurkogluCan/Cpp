




/* Bu ornekte "int &func()" fonksiyonu referans donusu olan bir fonksiyondur ve static int olan g'yi doner. Nesneyi referans olarak doner.
   C++'da;q
   "Tur &func(...)" prototipindeki bir fonksiyona "func() = ..." seklinde yapilan cagri ifadesi "lvalue expression" sol deger 
   ifadesidir.
   "func() = ..."  gibi bir atama durumu da mumkundur. Burada func donusu g'nin referansidir ve g'nin referansina
   bir deger ataniyor diye dusunulmelidir.
   -> func() = 45;    veya    int &r = g;
                              r = 45;
   
   -> Tur &r = func();
*/

/*
    ---------------------------------------------------- R E F E R A N C E ----------------------------------------------------
    Referanslar C dilinde XXX * const ptr; ifadesine benzetilebilir. (XXX değişken tipidir, örn int)

    1* Referanslara ilk deger vermek mecburi.
    -> int ival = 10;
    -> int &r   = ival;                         // Lvalue expression
       int &r{ival};
       int &r(ival);

    2* Referanslara ilk deger veren sol taraf degeri ile reference turu ayni olmak zorunda.
    -> int ival = 10;
    -> double &r   = ival;                       ❌ - ERROR                  
       double &r   = (double&)ival;              ✔  - OK 
       int &r      = ival;                       ✔  - OK
    
    3* Bir rvalue expression bir lvalue referansa ilk deger veremez. 
    -> int x     = 10;
       int &r    = x + 10;                       ❌ - ERROR 
       double &r = (double)ival;                 ❌ - ERROR 

    4* Bir referans bir nesneye baglanir, sonrasinda baska bir nesneye baglanamaz(Pointer Ref haric). Yani gosterdigi adres sonradan degistirilemez(const* ptr gibi)
    -> int x     = 10;
       int &r    = x + 10;                       ❌ - ERROR
       double &r = (double)ival;                 ❌ - ERROR

    5* Bir pointer kendisine referans alabilir.
    -> int x     = 10;           (int x)
       int *ptr  = &x;           (int * ptr)  = (int *)x 
       int *&rp  = ptr;          (int * &rp)  = ptr
                   
    6* Bir dizi kendisine referans alabilir.
    -> int a[5]      = {0,1,2,3,4};  
       int (&ra)[5]  = a;           
                        
    7* Referans kullaniminda pointerda oldugu gibi NULL pointer semantigi yoktur.

    8* Elemanlari referans olan bir referans dizisi olamaz.

    9* "Tur &func(...)" prototipindeki bir fonksiyona "func() = ..." seklinde yapilan cagri ifadesi "lvalue expression" sol deger 
        ifadesidir. Bu sayede deger atanabilmektedir.
        func(...) fonksiyonu nesneyi referans olarak doner. Bu yuzden referansa ilk deger vermede de kullanılabilmektedir.
        
        -> func() = 10;
        -> Tur &r = func();
    
    10* Referans ile pointer kullanmak assembly kod acisindan neredeyse aynidir. Derleyici icin neredeyse bir fark yoktur.
    
    11* Referanslarda null durumu yoktur.
 
    12* Elemanları nesne referansı(adresi) olan pointer dizisi olabilirken, referans dizisi
 
 
    ---------------------------------------------------- R E F E R A N C E  ve  C O N S T ---------------------------------------
    

    1* Referance'lardki "Tur * const ptr" karsiligi      ❌  (tur * const ptr)
    -> int x = 10;
       int &const r = x;
       Bu kullanim dogru bir kullanim degildir. Cunku referanslarin gosterdigi nesne zaten degistirilemez, baska bir nesnenin yerine gecemez. 
       Dogustan kenidisi const'tur.
       Derleyici Syntax hatasi vermeyebilir fakat uyari verir. 

    2* Referance'lardki "const Tur *ptr" karsiligi        ✔  (const tur *ptr)
    -> int x = 10;
       const int &r = x;
    -> const Tur *foo(...)
       Bu kullanimla birlikte r'nin gosterdigi x yalnizca salt okunabilir olarak kullanilabilinecektir. x'in degeri degistirilemez.




    ---------------------------------------------------- N U L L ----------------------------------------------------------------
    C'de "NULL"  bir makrodur. Tanimi;
    #define NULL (void *)0
    -> int *ptr = NULL;
       ptr = 0;
    C++'de nullptr vardır.  nullptr bir sabittir ve bir turu vardır. Bu turun ismi nullptr_t'dir.
    typedef decltype(nullptr) nullptr_t; 
    -> int *ptr = nullptr_t;
 
    Referanslarda null durumu yoktur.


******************************************************************************************************************************************/

/* Const Referans
 *************************************
 
 Referans tanımlamanırken normalde sabit bir değer atanamaz, l-value bir nesne atanabilir. Fakat const referans nesnelere sabit değerlerin atanması da geçerlidir.
 
 -> const int &cr1 = 10;
 bildirisinde derleyici tarafından geçici bir
 nesne oluşturulur ve const kabul edilir. Bu yüzden bu ifade geçerlidir.
 *************************************
*/
 #include <iostream>


 void func(const int &cr2)
 {
     
 }


 int main()
 {
           int &r1  = 10;      // Bu ifade geçersizdir ❌
     func(r1);
     
     const int &cr1 = 10;      // Bu ifade geçerlidir ✅
     func(cr1);
     

 }





// ----------------------------------------------------------------------------------------------------------------------------------
// AUTO

#include <iostream>


double foo(){
    return 1.0;
};
int boo(int){
    return 10;
};


int main()
{
    // int h = 20
    const int cx = 20;
    auto h = cx;       // int h = 20
    
    // int y
    int  x = 10;
    auto y = x;
    
    // double z
    auto z = foo();
    
    // int q = 0;
    auto q = 0;
    
    // int a, referanslık düşer
    {
        int xx = 10;
        int &rx = x;
        auto a = rx;
    }
    
    // int a, referanslık ve constluk  düşer
    {
        int xx = 10;
        const int &rx = x;
        auto a = rx;
    }
    
    // int *ax = a
    {
        int a[10];
        auto ax = a;
    }
    
    //  const int *ax = a, tur cikarimi yapilirken const a, array to pointer conversion ile array decay ile const int* turune donusecektir.
    {
        const int a[] = {1,2,3};
        auto ax = a;
    }
    
    //  int(*fp)(int) , function pointer
    {
        auto f = boo;
    }

    //  int &r = x, auto referans
    {
        int  x  = 10;
        auto &r = x;
    }
    
    //  const int &r = x, constluk dusmez
    {
        const int  cx  = 10;
        auto &r = cx;
    }
    
    //  int (&r)[3] = x, constluk dusmez
    {
        int a[3] = {1,2,3};
        auto &r = a;
    }
    
    
}

/* Type Deduction - Tur Cikarimi
 *************************************
 
 AAA(Almost Always auto)
 - auto ile yaratılan nesnenin ilk değer ataması zorunludur.
 - auto ilk değer atamasinda {} ifadesini kullanmak sorun olabilir.
 
 Reference collapsing:
 Eger icerisinde bir tane bile sol taraf referansı(&) varsa sol taraf referansına, yoksa sağ taraf(&&) referansına bağlanır
 - int &   &r   -> int  &r
 - int &   &&r  -> int  &r
 - int &&   &r  -> int  &r
 - int &&  &&r  -> int &&r
 *************************************
 */





// ----------------------------------------------------------------------------------------------------------------------------------
/* CONSTEXPR
 *************************************
 - Sabit ifadeler, derleyicinin koda bakarak doğrudan bir sabit elde ettiği ifadelere denir. Yani
   ifadenin değeri runtime değil compiler time'da bellidir.
 
 - *** CONSTEXPR fonksiyon; girdileri, içerisinde yapılan işlemler ve dönüşü sabit olan fonksiyonlara denir. Bu tip fonksiyonların
   içeriği sabit olduğu için fonksiyonun geri dönüş değeri de diğer sabitler gibi runtime'da değil de compiler time'da elde edilir.
 - *** constexpr fonksiyonların çıktıları compiler time'da elde edildiği için bu fonksiyonun içerisine yazılan kodlar gizlenemez. Eğer
   lib yapılmak istenirse veya fonksiyon başka dosyalardan çağırılacaksa başlık dosyasına yazılmalıdır ki derleyici compiler time'da sonucu üretebilsin.
   *** Bu yüzden CONSTEXPR FONKSİYONLARIN İÇERİĞİ KESİNLİKLE GİZLENEMEZ.
 - constexpr fonksiyonlar inline fonksiyonlardır.
 
 - constexpr belirteci ile yapılan tanımlamalar sabit olarak kabul edilir.
 - constexpr ile tanımlanan değişkenlerin kullanıldığı ifadeler de birer sabit ifadeleridir.
 
 *************************************
*/

// Include
#include <iostream>


// Func
constexpr int sum_square(int x, int y)
{
    return x*x + y*y;
}


//
int main()
{
    // Sabit ifadeler, dizi tanımlaması sırasında index constexpr ifadeler ile yapılmıştır. Const anahtar sözcüğü ile de geçerlidir.
    // Bu ifade C'de geçersizdir.
    {
        constexpr int x = 10;
        constexpr int y = 20;
        
        int a[x+y]{};   // Dogru
    }
    
    //** Const anahtar sözcüğü kullanarak sabit olmayan ifadelerle yapılan tanımlamanın sonucu da const değildir. Fakat hata da değildir.
    {
        int x = 10;
        int y = 20;
        const int b = x+y;
        int a[b]{};             // HATA
    }
    
    //** Constexpr anahtar sözcüğü kullanarak sabit olmayan ifadelerle yapılan tanımlama GEÇERSİZDİR.
    {
        int x = 10;
        int y = 20;
        constexpr int b = x+y;        // HATA
    }
    
    // Constexpr örnek ifade
    {
        const int x = 10;
        const int y = 20;
        constexpr int b = x*x + y*y;        // GEÇERLİ
    }
    
    // Constexpr örnek ifade
    {
        constexpr int x = 10;
        constexpr int y = 20;
        constexpr int b = x*x + y*y;        // GEÇERLİ
    }
    
    //** CONST vs CONSTEXPR
    //   constexpr anahtar sözcüğü kullanılarak yapılan ilk değer atamasında kullanılan fonksiyon mutlaka "constexpr fonksiyon" olmalıdır.
    //   Bu zorunluluk const için yoktur.
    {
        int foo();
        
        const int x = foo();          // GEÇERLİ

        constexpr int y = foo();      // HATA
    }
    
    //** CONSTEXPR fonksiyon, girdileri, içerisinde yapılan işlemler ve dönüşü sabit olan fonksiyonlara denir. Bu tip fonksiyonların
    // içeriği sabit olduğu için fonksiyonun geri dönüş değeri de diğer sabitler gibi runtime'da değil de compiler time'da elde edilir.
    // Eğer fonksiyon içerisinde sabitliği bozan ifadeler kullanılırsa hata verir ve geçersizdir.
    {
        const int a = 2;
        const int b = 3;

        constexpr int y = sum_square(a+5, b*2);   // GECERLİ, Derleyici için sabit bir ifadedir.
        int arr[sum_square(a+5, b*2)]{};          // Sabit bir ifade olduğu için dizinin boyutu da yapılabilir
    }
    
    //** CONSTEXPR fonksiyon, HATALI
    {
        int a = 2;
        int b = 3;

        constexpr int y = sum_square(a,b);   // HATALI, fonksiyon parametreleri sabit olmalı
    }
    
}



// ----------------------------------------------------------------------------------------------------------------------------------
/* Auto Return Type

 - auto geri dönüşe sahip olan fonksiyonlarda "->" tokenı kullanılarak
   geri dönüş tipi belirtilebilir.
 - Bu yöntem daha çok generic programlama fonksiyon şablonlarında kullanılmaktadır.
*/

// Include
#include <iostream>


// Func
auto func(int x) -> double;
    
auto func(int *) -> int *(*)(int *);
    

//
auto main() -> int
{
    
}



// ----------------------------------------------------------------------------------------------------------------------------------
/* DEFAULT ARGUMENTS

 - Varsayılan argüman öyle bir mekanizmadır ki fonksiyon bildiriminde yapılan bir belirtmeyle, fonksiyon çağrısı sırasında argüman gönderilmeyen parametre değişkenlerine, fonksiyon bildirimi veya tanımlaması sırasında, daha önceden, geçilmiş olan varsayılan argüman değerleriyle fonksiyona çağrıda bulunulması.
 - Yani, ben bu parametreye argüman göndermiyorum, sevgili derleyici bildirimde belirtilen argümanla bu fonksiyonu çağır
 - Fonksiyon bildirilerinde fonksiyon parametresine geçilecek olan "varsayılan argümanlar" sabit, değişken, fonksiyon geribildirimleri gibi ifadeler olabilir.
 - Varsayılan argümanlar istenilen parametreden verilmeye başlanılabilir fakat varsayılan argüman verilen parametrenin sağındaki bütün parametrelere de varsayılan argüman geçilmelidir. Solundaki parametrelere verilme zorunluluğu yoktur.
 - Eğer varsayılan argümanlar fonksiyonun bildiriminde geçilmişse, fonksiyon tanımında tekrardan yazılması syntax error'a sebep olur. Bunun tersi de geçerlidir. Yani varsayılan argümanlar ya bildirimde ya da tanımda geçilebilir.
*/


// Include
#include <iostream>



// Func


// 1
int func ( int x, int y = 10);

// 2
int func_2 ( int x = 5, int y = 10 );

// 3 - HATA
int func_3 ( int x = 10, int y );

// 4
int foo();
int func_4 ( int x, int y = foo());

// 5
int ab;
int func_5 ( int x, int y = ab);

// 6
int g = 10;
int func_5 ( int &r = g);


// 8
int func_8 ( int d = 100, int m = 200, int y = 300);


// 7 - HATA, redefiniton of default argument
int func_7 ( int d = 10, int m = 1, int y = -1);

int func_7 ( int d = 10, int m = 1, int y = -1)
{
    
}

// 9
int func_9 ( int , int , int );

int func_9 ( int d = 10, int m = 1, int y = -1)
{
    
}

// 10
int func_10 ( int , int = 3, int = 45);

int func_10 ( int d , int m , int y )
{
    
}



//
int main()
{
    
    func_8();           // d = 100, m = 200, y = 300
    func_8(1);          // d = 1,   m = 200, y = 300
    func_8(1,2);        // d = 1,   m = 2  , y = 300
    func_8(1,2,3);      // d = 1,   m = 2  , y = 3
    
    
}



// ----------------------------------------------------------------------------------------------------------------------------------
/* INCOMPLETE TYPE (FORWARD) DECLERATION:
 
 - Derleyici bir türün varlığından haberdar fakat o türün tanımıyla(örneğin yapının elemanlarıyla ) karşılaşmamışsa bu tür incomplete type'dır.
 - Incomplete türünden nesne yaratılamaz çünkü derleyicinin nesne yaratabilmesi için boyutunu bilmesi gerekmektedir.
 
*/


// Include
#include <iostream>


// Yapılar
struct NECO;    // incomplete type, tamamlanmamis tur



// Func

struct NECO foo(struct NECO *);   // GECERLI
typedef struct NEOCO  necati;     // GECERLI


//
int main()
{
    struct NECO *p;   // GECERLI
    
    struct NECO x;    // HATALI, Derleyicinin nesne olusturabilmesi icin yer ayırması lazım. Bu yüzden de NECO'nun boyutunu bilmesi gerekir

    int x = sizeof(struct NECO);   // HATALI, Incomplite type kullanilamaz
}


// ----------------------------------------------------------------------------------------------------------------------------------
/* ENUM
 
 - C'de enum türü arka planda derleyicinin kullandığı tür(underline type) integer olmak zorundadır.
 - C++'da enum türünün arkasında kullanığı veri tipinin garantisi yoktu. Numaratör değelerine bakılarak derleyici uygun veritipini seçebilirdi. Fakat Modern C++ ile birlikte gelen önemli eklentilerden birisi olan enum veri tipini(underline type ,baz türünü) kendimizin belirleyebilmemizdir.
 
 - C++'da normal enumlarda ve enum class'larda underline type belirlenebilmekte. Böylece numaratörlerin sahip olacağı veri tipi karmaşasının önüne geçilebilmektedir.
 
 - Diğer türlerden enum türüne dönüşüm yoktur fakat enum türünden diğer türlere dönüşüm bulunmaktadır.
 
 - ENUM türleri unscope olduğu için isimleri aynı iki farklı enum türünün içerisindeki numaratörler hata verecektir. Bu durumun önüne geçilmesi için C++'da enum class mevcuttur.

 - Enum class'lar aslında kapsamlandırılmış enumlardır. Yani içerisindeki numaratörlere unscope şekilde erişim imkanım olmuyor. Enum class ismi üzerinden ulaşabilmekteyim.
 - Enum class'lara da underline type geçilebilmektedir. Eğer geçilmezse default olarak int atanmaktadır.
 
 
*/


// Include
#include <iostream>


// Yapılar

/* 1 - Unscope ornek
 
// color.h
enum Color
{
    RED,
    YELLOW,
    GREEN
};

// traffic.h
enum TraficColor
{
    RED,
    YELLOW,
    GREEN
};
*/


enum Color
{
    RED,
    YELLOW,
    GREEN
};


// Underline type ENUM
enum Color_underline : int
{
    int_RED,
    int_YELLOW,
    int_GREEN
};


// ENUM CLASS
enum class Color_EC : unsigned int
{
    RED,
    YELLOW,
    GREEN
};

enum class Traffic_EC : unsigned int
{
    RED,
    YELLOW,
    GREEN
};



// Func


//
int main()
{
    
    // Tur donusumu
    {
        Color myu_color = RED;
        int x = myu_color;
    }
    
    
    // SCOPE
    {
        Color_EC color = Color_EC::RED;
    }

}



// ----------------------------------------------------------------------------------------------------------------------------------
/* DECLTYPE
 
 decltype(x)
 - Decltype anahtar sözcüğü, tür bilgisi kullanılan her yerde kullanılabilmektedir.
 - decltype(x) ifadesinde x'in türü neyse ifadenin sonucu da odur.
 - decltype ile auto arasında bazı çıkarımsal farklılıklar bulunmaktadır. auto kullanımı biraz daha tercihe bağlıdır fakat decltype bazı yerlerde zorunluluk olabilir.
 
 - decltype'da auto'da olduğu gibi cont düşmez.
 - decltype'da array to pointer conversion yapılmaz.
 
 - * decltype operandı eğer bir isimse, doğrudan ismin türünü alır.
 - * decltype operandı eğer bir ifadeyse aşağıdaki durumlara göre tür belirlenir.
 
 Eğer Decltype Operandı İfade ise Tür Durumları
 1- Eğer decltype'ın operandı olan ifade PR value kategoreisinde ise elde edilen tür(T) doğrudan ifadenin türüne(T) eşittir
 2- Eğer decltype'ın operandı olan ifade L  value kategoreisinde ise elde edilen tür(T) ifadenin türünün referansına(&T) eşittir
 3- Eğer decltype'ın operandı olan ifade PR value kategoreisinde ise elde edilen tür(T) ifadenin türünün refref(&&T) eşittir
 
 decltype(T), T bir ifade
 1- PR value ise tür ->   T türüdür
 2-  L value ise tür ->  &T türüdür
 3-  X value ise tür -> &&T türüdür
 
 
 !!! VALUE EXPRESSION
 - Bir isim şeklinde olan bütün ifadeler lvalue expression’dır.
 - Value kategorilerinden bahsedebilmek için bir ifade olması lazım. Bildirimlerin value kategorisi olmaz, ifadelerin olur.
 
*/


// Include
#include <iostream>


// Yapılar


// Func


//
int main()
{
    
    // - int a
    {
        int x = 10;
        decltype(x) a;
    }
    
    // - double a
    {
        int x = 10;
        decltype(x + 3.5) a;
    }
    
    // - int *ptr
    {
        int x = 10;
        decltype(x) *ptr;
    }
        
    // - const int *ptr
    {
        int x = 10;
        const decltype(x) *ptr;
    }
    
    // - const int *ptr, CONSTLUK DUSMEZ
    {
        const int x = 10;
        decltype(x) *ptr;
    }
    
    // - int b[10]
    {
        int a[10]{};
        decltype(a) b;
    }
    
    // - int &y
    {
        int x = 10;
        int &r = x;
        decltype(r) y = x;
    }
    
    
    
    //*** DECLTYPE DURUMLARI - Operand isim
    {
        int x = 10;
        decltype(x) a;  //int a
    }
    
    //*** DECLTYPE DURUMLARI - Operand L value
    {
        int x = 10;
        int b = 10;
        decltype((x)) a = b;   // int &a
        
        // !!! decltype(x) bir isim operandı iken decltype((x)) bir ifadedir ve L value expressiondır.
    }
    
    
    //*** DECLTYPE DURUMLARI - Operand L value
    {
        int x = 10;
        int b = 10;
        
        decltype(++x) a = b;   // int &
    }
    
    
    //*** DECLTYPE DURUMLARI - Operand X value
    {
        int &&foo();
        
        decltype(foo()) a = 10;   // int &&
    }
    
    
    //*** DECLTYPE DURUMLARI - Operand PR value
    {
        int x = 10;
        
        decltype(x+5) a;   // int
    }
    
    
    //*** DECLTYPE DURUMLARI - Operand PR value
    {
        int x = 10;
        
        decltype(x++) a;   // int
    }

}



// ----------------------------------------------------------------------------------------------------------------------------------
/* FUNTION OVERLOADING(Fonksiyon Yüklemesi)
 
 
 Funtion Overloading Giriş:
 -------------------------
 Funtion overloading tanımına girmdeden önce şöyle bir örnek verelim.
 
 Aritmektik işlem operatörü olan '+' işaretinin kullanımı sırasında;
    Eğer 'int'   türünden değişkenlerle toplama yaparsam arka planda üreteceği makina kod farklı,
    Eğer 'float' türünden değişkenlerle toplama yaparsam arka planda üreteceği makina kod farklı olacaktır.
 Bu durumda derleyici bize tamsayılar için farklı gerçek sayılar için farklı bir operatör kullacaksın dese saçma ve gereksiz olurdur.
 İşte function overloading de buna benzemektedir.
 
 
 Funtion Overloading Genel Tanım:
 --------------------------------
 Aynı isme sahip ve aynı işlevi gerçekleştiren, farklı türden ve sayıdan parametre bildirilere sahip olan fonksiyonların tanımlanmasına ve kullanılmasına "Fonksiyon Overloading" denir. Funciton overolading'in ana kullanım amacı, ana işlevleri benzer olan fonksiyonların, parametre değişikliğine bağlı olarak farklılaşmasını engellemek, aynı isimle overload ederek farklı fonksiyonlar gibi kullanabilmektir. Overload edilen fonksiyonların içeriği birbirlerinden farklı olabilir ama fonksiyonun amacı aynı olmalı ki kullanıcı tarafından hatalı kullanım olmasın.
 
 ---------------------------

 Fonksiyon yüklemesinden söz edilebilmesi için iki koşulun sağlanması gerekir:

 1) Aynı isimli birden fazla fazla fonksiyon aynı kapsamda (scope) var olmalı.
 2) Fonksiyonların imzaları farklı olmalıdır.

 
 Function Signatur(Fonksiyon İmzası):
 ------------------------------------
 Bir fonksiyonun geri dönüş türü hariç, fonksiyonun ismi, parametre tipleri ve parametre sayısını belirten bilgiye "fonksiyonun imzası" denir.  Fonksiyonun geri dönüş değerinin türünü fonksiyonun imzasının bir parçası olarak görmeyeceğiz
    
 // Imzaları aynı
         int func(int)
         double func(int);

 
 Scope Kuralları:
 ----------------
 Bildirilen fonksiyonların scope'ları aynı olmalıdır. Eğer scopelar farklıysa Function Overloadingden BAHSEDİLEMEZ.
 
 //Scope Tipleri
    Namespace scope (file scope in C)
    Class     scope
    Block     scope
    Function prototype scope
    Function scope
    
 Token(Atom) ve Name Lookup(İsim Arama):
 ---------------------------------------
 Derleyici açısından kaynak kodun en küçük birimidir. Örneğin isimler. Derleyici kodu atomize eder. Kodun derlenme sırasında derleyicinin bir isimle karşılaşıp bu ismi araması durumuna "Name Lookup" denir.
 
 
 İsim arama kuralları:
 
 1)
 
 Derleyici ismi ararken önce kendi scope'una, sonra bütün kapsayan scope'lara, eğer yine bulamazsa bütün global olanlarda arar.
 Fakat C++'da "Scope Resolution, ::" operatörü kullanılarak derleyiciye, derleyici sen bu ismi global alanda ara diyerek farklı bir scope araması yaptırabiliriz.
 
 ------------
 int a;             // Global alan
 
 int main()
 {
    float a = 1.5f;
 
    cout << a;        // Burada derleyici öncelikle kendi scope'una bakacağı için gloabelde tanımlı olan a'nın hiçbir önemi yoktur.
 }
 
 ------------
 
 int main()
 {
    int printf = 10;
 
    printf("enescan");     // Burada derleyici öncelikle kendi scope'una bakacağı için standart kütüphanede
                           // tanımlı olan printf'in hiçbir hiçbir önemi yoktur.
 }

*/


// Include
#include <iostream>


// Yapılar


// Func


//
int main()
{
    
   
}



// ----------------------------------------------------------------------------------------------------------------------------------
/* FUNTION OVERLOADING(Fonksiyon Yüklemesi).2
  - Funciton overloading giriş seviye örnekleri
*/


// Include
#include <iostream>
// Yapılar

// Func
int foo(int, int);
 foo(int, int);


//
int main()
{

    // - Function redeclaration, overloading değil
    {
        int foo(int, int);
        int foo(int, int);
    }
    
    // - Hatalı kullanım, imzaları aynı ama geri dönüşü farklı
    {
        int    foo(int, int);
        double foo(int, int);
    }
    
    // - CONST: Kullanıcıyı korumak yoluyla yapılan constlar, top level constlar, imzayı değiştirmez.
    //  Bu yüzden aşağıdakiler overloading değil, redeclaration'dır.
    {
        int foo(const int);
        int foo(int);
        
        int func(int *);
        int func(int *const);
    }
    
    // + const: "Const Overloading"
    {
        int func(const int *);
        int func(int *);
        
        int foo(const int &);
        int foo(int &);
    }
    
    // - Default Arg, Function redeclaration
    {
        int func(int x);
        int func(int x=10);
    }
    
    // + Default arg
    {
        int func(int x);
        int func(int x, int y=10);
    }
   
    // + Referans, ÇOK TEHLİKELI
    {
        int func(int &x);
        int func(int x );
    }
    
    // + Referans ve pointer
    {
        int func(int &);
        int func(int *);
    }
   
}



// ----------------------------------------------------------------------------------------------------------------------------------
/* FUNTION OVERLOADING(Fonksiyon Yüklemesi.3
 
 Derleyicinin Çağırılacak Olan Fonksiyonu Belirlemesi(Function Overload Resolution)
 ----------------------------------------------------------------------------------
 Kullanıcı bir fonksiyon çağrısında bulunur. Derleyici, overload edilmiş olan fonksiyonlara bakar ve hangisi bu çağrı için uygundur diye karar verir fakat
 
 - Nomatch  : Çağırılan fonksiyon, overload edilen fonksiyonlardan hiçbirisine uymuyorsa "Nomatch" durumu vardır. Overloaddan dolayı değil, fonksiyon çağrısı fonksiyon bildirilerine uymadığı için hataya sebep olur.
 
 - Ambiguity(İkilem): Derleyicinin, fonksiyon çağrısına uygun olan overload edilen fonksiyona karar verememesi durumu.
 
    void func(long double);
    void func(char);
 
    int main()
    {
        func(2.3);     // - HATA, HANGİSİNİN SEÇİLECEĞİNE KARAR VERİLEMEZ, Ambiguity
    }
 
 Fonksiyon Overloading Karar Esasları
 ------------------------------------
 Overload edilen fonksiyonlara çağrı yapıldıktan sonra karasız kalma durumlarında aşağıdaki esaslara göre karar verilir.
 
 1) Variadic (En az şansı olan)
      foo(int, ...);
 
 2) User Defined Conversion (Orta seviye şans)
    
    struct A
    {
        A();
        A(int);
    }
 
    void func(A);
 
     int main()
     {
        func(10);
     }

 3) Standart Conversion (En şanslısı):
    ---------------------------------
    Dil tarafından syntax kurallarıyla belirli dönüşümlerdir. Veritipleri arasındaki dönüşümler, int->double, char-> int .....
    Buarada dilin kurallarınca LEGAL kabul edilen ifadeler geçerlidir. Örneğin double->int dönüştürdüm veri kaybı olmaz mı gibi şeyler karar aşaması için önemli değildir.
 
    Standart conversion içerisinde aşağıdaki 3 maddeye göre fonksiyona karar verilir. İki yada daha fazla uygun fonksiyon arasında argümandan parametre değişkenine yapılan dönüşümlerin kazanma sıraları "Exact math -> Promotion -> Conversion"dır.
 
 
    3.1) Exact Match (Tam uyum) : Argüman olan ifadenin türünün, parametre değişkeninin türüyle tamamen aynı olması.
         ------------------------
        void func(int);
        func(12);
    
    // const conversion, const olmasına rağmen exact match kabul edilir.
        void foo(const int *);
        int x = 10;
        func(&x);
 
 
    3.2) Promotion   (Yükseltme): Int altı türlerin int türüne olan ve float'dan double'a yapılan yükseltmelerdir, argüman -> parametre
         ------------------------
 
    int altı türler:
 
        bool
        
        char
        unsigned char
        signed char
        
        unsigned short
        signed short

 
    3.3) Conversion  (Dönüşüm)  :  Bu iki madde harici. Argümandan parametreye dönüşümü varsa. En basit olarak int->float
         ------------------------
 
    Çoklu Argüman Fonksiyon Kararı
    ------------------------------
    Çoklu parametreye sahip overload fonksiyonlarda karar verilirken;
    Argümanlardan en az biri için ilgili parametre değişkenine dönüşüm kalitesi diğerlerine göre daha iyi olacak, ancak diğer argümanları için de daha kötü olmayacak.
    L.193
 
 
    Funtion Delete
    ------------
    C++'da fonksiyonlar delete edilebilir. Bir fonksiyonun delete edilmesi, bu fonksiyon var ama çağırılsa hata olacak demektir.
    
    void func(int) = delete;
 
    // -, Function Delete, fonksiyon var ama delete edildiği için syntax hatası verir.
    {
     void foo(int) = delete;
     void foo(char) = delete;
     void foo(double);
     
     {
         foo(12);
     }
 
*/


// Include
#include <iostream>
// Yapılar



//
int main()
{

    // -, Ambiguity, conversion
    {
        int foo(long double);
        int foo(char);
        
        {
            foo(12.);
        }
    }
    
    // +, const int *
    {
        int foo(int *);
        int foo(const int*);
        
        {
            int x = 10;
            const int y = 20;
            
            foo(&x);  //1
            foo(&y);  //2
        }
    }
    
    // +, const int &
    {
        int foo(int &);
        int foo(const int&);
        
        {
            int x = 10;
            const int y = 20;
            
            foo(x);  //1
            foo(y);  //2
        }
    }
    
    // -, Ambiguity, Default argument
    {
        int foo(int, int = 10);
        int foo(int);
        
        {
            foo(12);
        }
    }
    
    // -, Ambiguity, referans ve değer
    {
        int foo(int &);
        int foo(int  );
        
        {
            int x = 10;
            
            foo(x);  //1
        }
    }
    
    // +, Exact match ve promotion
    {
        int foo(bool );
        int foo(int  );
        
        {
            foo(12);    // 2
            foo(12>4);  // 1
        }
    }
    
    // +, rvalue
    {
        int foo(int &);
        int foo(int &&);
        
        {
            int x = 10;
            
            foo(x);     //1
            foo(x+3);   //2
        }
    }
    
    // +, İstisnai bir durum. Her ikisi de conversion olmasına rağmen ambiguity olmaz.
    {
        int foo(bool  );
        int foo(void *);
        
        {
            int x = 10;
            
            foo(x);     //1
        }
    }
    
    
    // -+, Birden fazla elemanla karar verme
    {
        int foo(int,   double,       long  );
        int foo(char,  int,          long  );
        int foo(double,unsigned int, double);
        
        {
            foo(12, 12,   13L);    //-
            foo(12, 12.L, 34U);    //+
        }
    }
    
    // -, Function Delete, fonksiyon var ama delete edildiği için syntax hatası verir.
    {
        void foo(int) = delete;
        void foo(char) = delete;
        void foo(double);
        
        {
            foo(12);
        }
    }
   
}



// ----------------------------------------------------------------------------------------------------------------------------------
/* Typecasting (Tur Donusumu)
    
 C'de kullanılmakta olan casting operatörleri C++'da geçerli olmakla birlikte önerilmez. C++'da tür dönüşümleri için özelleşmiş tür dönüşüm operatörleri bulunmaktadır. Bunlar;
 
 1-) Static Cast ( static_cast<T>(ifade), Örn. T = int )
 
 - Static tür dönüşümleri için kullanılmaktadır. Mesela aritmetik türler arasındaki dönüşümler için kullanılır. int->double, double->int, long->char vb. kullanımları static tür dönüşümüne örnektir. Enum typelar ile aritmetik türler arasında olan veya enum typeların kendileri arasındaki dönüşümleri de statik tür dönüşümlerine birer örnektir.
 - İstisna olarak (void *)->(T *) olan dönüşümler de statik tür dönüşümüne örnektir.
 
 
 2-) Const Cast ( const_cast<T>(ifade), T = char, char * )
 
 - cv qualified(bir türün const veya volatile anahtar sözcüğü ile nitelenmiş hali) olarak nitelenmiş ifadelerin constluğunu kaldırmak için kullanılır.
 - const_cast işlemcisi, işlem yapılan nesnenin sabit ve/veya volatile özelliğini kaldırır veya yeniden kazandırır. Aslında, bir nesnenin const özelliğini kaldırma, o nesnenin bellekteki değerini değiştirmeden, sadece const olmayan bir değer kabul edilen bir ifade veya fonksiyon parametresinde kullanılmasını sağlar.
 
 
 3-)Reinterpret Cast ( reinterpret_cast <T> (ifade) )
 
 - reinterpret_cast işlemcisi bir veri türünü tamamen farklı bir veri türüne dönüştürür.
 
 
 4-) Dynamic Cast
 
 - Inheritance kısmında değinilecektir.

*/


// Include
#include <iostream>
// Yapılar



//
int main()
{

    
    
}



// ----------------------------------------------------------------------------------------------------------------------------------
/* Classes
    
 Class Elemanları
 ----------------
 class Data
 {
     int mx;             // Data member
     void func(int);     // Member function
     typedef int Word;   // Type member(member type, nested type)
 };

 Class Scope
 -----------
 Bir sınıfın tanımı içerisinde bildirilen tüm isimler "class scope" denilen özel bir kapsama sahiptir.
 
 
 Şu durumlarda bir isim class scope içinde aranır(Name lookup);
 
 1) "."  operatörünün sağ operandı olan isimler
 2) "->" operatörünün sağ operandı olan isimler
 3) "::" (scope resolution) operatörünün sağ operandı olan isimler
 
Unary: Tek operantlı scope resolution kullanımı. Eğer isimle ilgili bir işlemde, örneğin int tipinden bir değişken, unary çözünürlük operatörü kullanılırsa bu, derleyiciye ismi namespace scope'ta, global alanda ara demek olur(name lookup aşaması). Yerel scope'ta x değişkeni, ismi yer alsa bile global alanda arama yapılır.
 Örn. "::x"

 //
 int g = 10;

 int main()
 {
     int g = 20;
     
     ::g += g;           // Global alandaki g(::g(Unary)) ile localdeki g'nin toplamı
 }
 //
 
Binary: Çift operantlı scope resolution kullanımı. Binary çözünürlük operatörünün sol operandı olan isim ya bir namespace ismi, ya da bir class ismidir. Sağ operandındaki isim ise buna bağlı olarak class veya ilgili namespace scope'ta aranacaktır.
Örn. "a::b"
 
 
 Namespace (İsim Alanı)
 ----------------------
 İsimleri birbirinden gizlemek için kullanılan bir araçtır. Gloabal alandaki isimlerin birbirleriyle karışmasını engellemek için oluşturulmuş isim bölgeleridir. Namespace global alanı parselleyerek kendine özgü isim alanları yaratır.

 namespace Neco
 {
     int x = 64;
 }

 //
 int main()
 {
     int x = 1;

     std::cout << x << '\n';         // x = 1;
     std::cout << Neco::x << '\n';   // x = 64;
 }

*/


// Include
#include <iostream>
// Yapılar


class Data
{
    int mx;             // Data member
    void func(int);     // Member function
    typedef int Word;   // Type member(member type, nested type)
};



namespace Neco
{
    int x = 64;
}

//
int main()
{
    int x = 1;

    std::cout << x << '\n';         // x = 1;
    std::cout << Neco::x << '\n';   // x = 64;
}



// ----------------------------------------------------------------------------------------------------------------------------------
/* Classes
    
 Class Member Erişim Alanları
 ----------------------------
 C++'da isim arama(name lookup) tamamlandıktan sonra access kontrolü yapılmaktadır. Bu access kontrolünde ise sınıfın üyesi olan ismin aşağıda belirtilen yetkileri  kontrol edilmektedir.
 
 class Data
 {
    public: Sınıfın public bölümü herkese açık bölümüdür. Yani sınıfın bu alanındaki isimleri herkes kullanabilir.
 
    private: Sadece sınıfın kendi içerisinde kullanılabilen, client kodlar tarafından kullanılamayan isimlerdir.
 
    protected: Kalıtım konusuyla ilgilidir, daha sonra değinilecektir.
 };

 
 - Classlar tanımlanırken kendi içerisinde "public", "private" ve "protected" anahtar sözcükleri kullanılarak ilgili alanlara ayrılabilir.
 -- Class'ın kendi içerisindeki alan default olarak "private" alandır. Yani class içerisinde hiçbir alan anahtar sözcüğü kullanılmazsa, içerisindeki üyeler private alanlı olacaktır.
 -- Struct'ın kendi içerisindeki alan default olarak "public" alandır. Yani struct içerisinde hiçbir alan anahtar sözcüğü kullanılmazsa, içerisindeki üyeler public alanlı olacaktır.
 
 
 class Data
 {
            // PRIVATE ALAN
    public:
            // PUBLIC ALAN
    private:
            // PRIVATE ALAN
    public:
            // PUBLIC ALAN
    protected:
            // PROTECTED ALAN
 }
 
 MEMBER
 ------
 Classın "member function" ve "Data member"ları static ve non-static olarak 2'ye ayrılmaktadır.
 
 1) Eğer sınıfın üyesinin bildiriminde static anahtar sözcüğü varsa bu member static ömürlüdür ve ilgili sınıf için tektir. Bu sınıftan ne kadar nesne yaratılırsa yaratılsın bütün nesneler aynı membera erişir, her nesne için yeniden yaratılmaz.
 2) Eğer sınıfın üyesinin bildiriminde anahtar sözcüğü yoksa bu member static ömürlü değildir ve ilgili sınıftan yaratılacak olan nesneler için yeniden oluşturulur. Bütün nesneler için farklıdır.
 
 
*/


// Include
#include <iostream>
// Yapılar


class Data
{
    int mx;             // Data member
    void func(int);     // Member function
    typedef int Word;   // Type member(member type, nested type)
};


//
int main()
{

}



// ----------------------------------------------------------------------------------------------------------------------------------
/* Classes Member Functions
 
 Class Member Function:
 ->i: Sınıfların üye fonksiyonları sınıf scope'u içerisinde overload edilebilir. Public ve private alanda olması overloadinge engel değildir, önemli olan scope'tur. Public, private ve protected alanlar aynı scope alanı içerisindedir.
 
 // Function overloading
 class Data
 {
 private:
     void func();
 public:
     void func(int);
     void func(int,int);
 };
 
 
 ->i: Sınıfların üye fonksiyonlarının sınıf türünün sizeof'uyla bir ilgisi yoktur. Yani sınıf türünden yaratılan her nesne için fonksiyon tekrar yaratılmaz, sınıf nesnelerinin boyutunu arttırmaz.
 
 
 ->i: Sınıf içerisindeki non-static üye fonksiyonlarının ilk parametresi yaratılan, fonksiyona ulaşan, nesnenin adresini içerir. Bu parametre gizli bir parametredir ve kullanıcının yaratacağı fonksiyonun girdilerinden bağımsızdır. Non-static olduğu için fonksiyon çağrıldığında çağıran nesnein adresini içeriye almalı ki nesne üzerinde işlemlerini gerçekleştirebilsin. Member functionlar içerisinde çağırılan data member'lara atomic göstergeler olmadan ulaşılmasının sebebi de gizli parametredir. Gizli parametre olmasına rağmen data member'lara "this" anahtar kelimesi ile de ulaşılabilmektedir.
    Fakat static member function'lar sınıftan yaratılacak olan nesnelerden bağımsız ve tek olduğu için static ömürlü member functionlara sınıf ismi ve çözünürlük operatörüyle ulaşılabilmektedir çünkü gizli bir parametresi yoktur.
 
 // Function overloading
 class Data
 {
 private:
 public:
             void func(int);
     static  void staticfunc(int);
 };
 // Member function gizli parametre
 {
     Data::func(12);         // Gecersiz, non-static
     Data::staticfunc(12);   // Gecerli,  static
 }
 
*/


// Include
#include <iostream>
// Yapılar


// Function overloading
class Data
{
private:
public:
            void func(int);
    static  void staticfunc(int);
};



//
int main()
{
    // Member function gizli parametre
    {
        Data::func(12);         // Gecersiz, non-static
        Data::staticfunc(12);   // Gecerli,  static
    }

}



// ----------------------------------------------------------------------------------------------------------------------------------
/* Classes Member Functions - 2
 
 
 Member Function Definition
 --------------------------
 ->i: Member functionlar tanımlanırken bildirimleri sınıfın ismi ve çözünürlük operatörü kullanılarak yapılır. Eğer sınıf ismi kullanılmadan yapılırsa bu sınıfa ait bir fonksiyon olmaz.

 class Data {
 private:
     int mx;
     
 public:
     void func(int x);
 };
 
 // Sınıfa ait degil
 void func(<#int x#>)
 {
    // Normal bir fonksiyon
 }
 
 // Sınıfa ait
 void Data::func(<#int x#>)
 {
     mx = 10;
 }

 
 this
 ----
 ->i: this anahtar sözcüğü c++'da sınıf türünden yaratılmış olan bir nesnenin adresini ifade etmektedir. O yüzden ismi "this pointer"dır. Member functionlar içerisinden ulaşılacak olan data memberlar nasıl gizli parametreyle sadece member ismi kullanılarak ulaşılabiliyorsa(mx), this pointer kullanılarak da ulaşılabilir(this->mx)

 class Data {
 private:
     int mx;
     
 public:
     void func(int x);
 };

 // Asagida yapilan atamalar ozdestir
 void Data::func(int x)
 {
     mx = x;
     this->mx = x;
     Data::mx = x;
 }

 
 
 
*/


// Include
#include <iostream>
// Yapılar


//
class Data {
private:
    int mx;
    
public:
    void func(int x);
};



void Data::func(int x)
{
    mx = 9;
    this->mx = 10;
    Data::mx = 11;
}

//
int main()
{
    Data mydata;
    
    mydata.func(10);
    
    //
    {

    }

}


// ----------------------------------------------------------------------------------------------------------------------------------
/* const member func, mutable, default member initialize
 
 
 Const Member Function
 ---------------------
 ->i: Gizli parametrenin const olması istenen durumlarda, fonksiyonun sınıf içerisindeki ve tanımalama sırasındaki bildirimi sırasında bildirimin sonuna "const" anahtar sözcüğü koyulur. Eğer koyulmazsa default olarak const olmayan bir gizli parametreye sahip fonksyion yaratılır. Const koyulan fonksiyon üyelerini "get(...)", koyulmayanları ise birer "set(...)" fonksiyonlar olarak düşünebiliriz.
 
 //
 class Data {
 private:
     int mx;
     
 public:
     void getfunc(int x)const;
     void setfunc(int x);
 };



 void Data::setfunc(int x)
 {
     mx = x;
 }

 void Data::getfunc(int x)const
 {
     mx = x;    // HATA
 }
 
 
 // 2
 class Data {
 private:
     int mx;
     
 public:
     Data *foo();
     Data &func();
 };

 Data* Data::foo()
 {
     //...
     return this;
 }

 Data& Data::func()
 {
     //...
     return *this;
 }
 
 
 mutable
 -------
 ->i: Sınıfın bir veri elemanını mutable anahtar sözüğü ile tanımlamak şu anlama gelir, kodu okuyan sevgili kişi, bu veri elemanının değişmesi, sınıf türünden yaratılan bir nesnenin problem domainindeki anlamını değiştirmez. Yani bu değişse de değişmese de seni etkilemez. Örneğin sınıf içerisinde kullanılan ve dışarıyı etkilemeyen sayaçlar
 ->i: Mutable data memberlar const functionlar içeriside değiştirilebilir.
 
 //
 class Data {
 private:
     mutable int msayac;
     
 public:
     void getfunc(int x)const;
     void setfunc(int x);
 };

 void Data::getfunc(int x)const
 {
     msayac++;    // Dogru
 }

 
 Default member initializer
 ---------------------------
 ->i: Modern c++ ile birlikte gelen bir kullanımdır. Bir sınıf nesnesinin hayata getirilmesi durumunda onun veri elemanına ilk değer verilebilir.
 
 //
 class Data {
 private:
     int mx = 10;;
     
 public:
     Data &f1();
     Data &f2();
     Data &f3();
     
     int gmx = 20;
 };
 

*/


// Include
#include <iostream>
// Yapılar


//
class Data {
private:
    int mx = 10;;
    
public:
    Data &f1();
    Data &f2();
    Data &f3();
    
    int gmx = 20;
};




Data& Data::f1()
{
    //...
    return *this;
}


//
int main()
{
    Data mydata;

    // Bu kullanım geçerli ve doğrudur. Fonksiyon dönüşün nesnenin referansı olduğu için o referansla
    // tekrar farklı bir fonksiyon çağrısı yapmak veya data membera ulaşmak da mümkündür.
    mydata.f1().f2().f3();
    mydata.f1().f2().f3().gmx = 10;
    
    // mydata.f1() dönüşü -> mydata, bu yüzden dönüş üzerinden başka bir membera ulaşmak mümkündür.
    
    //
    {

    }

}



// ----------------------------------------------------------------------------------------------------------------------------------



// ----------------------------------------------------------------------------------------------------------------------------------



// ----------------------------------------------------------------------------------------------------------------------------------


// ----------------------------------------------------------------------------------------------------------------------------------



// ----------------------------------------------------------------------------------------------------------------------------------



// ----------------------------------------------------------------------------------------------------------------------------------



// ----------------------------------------------------------------------------------------------------------------------------------


// ----------------------------------------------------------------------------------------------------------------------------------



// ----------------------------------------------------------------------------------------------------------------------------------



// ----------------------------------------------------------------------------------------------------------------------------------



// ----------------------------------------------------------------------------------------------------------------------------------


