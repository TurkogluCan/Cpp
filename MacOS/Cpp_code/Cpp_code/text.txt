




/* Bu ornekte "int &func()" fonksiyonu referans donusu olan bir fonksiyondur ve static int olan g'yi doner. Nesneyi referans olarak doner.
   C++'da;q
   "Tur &func(...)" prototipindeki bir fonksiyona "func() = ..." seklinde yapilan cagri ifadesi "lvalue expression" sol deger 
   ifadesidir.
   "func() = ..."  gibi bir atama durumu da mumkundur. Burada func donusu g'nin referansidir ve g'nin referansina
   bir deger ataniyor diye dusunulmelidir.
   -> func() = 45;    veya    int &r = g;
                              r = 45;
   
   -> Tur &r = func();
*/

/*
    ---------------------------------------------------- R E F E R A N C E ----------------------------------------------------
    Referanslar C dilinde XXX * const ptr; ifadesine benzetilebilir. (XXX değişken tipidir, örn int)

    1* Referanslara ilk deger vermek mecburi.
    -> int ival = 10;
    -> int &r   = ival;                         // Lvalue expression
       int &r{ival};
       int &r(ival);

    2* Referanslara ilk deger veren sol taraf degeri ile reference turu ayni olmak zorunda.
    -> int ival = 10;
    -> double &r   = ival;                       ❌ - ERROR                  
       double &r   = (double&)ival;              ✔  - OK 
       int &r      = ival;                       ✔  - OK
    
    3* Bir rvalue expression bir lvalue referansa ilk deger veremez. 
    -> int x     = 10;
       int &r    = x + 10;                       ❌ - ERROR 
       double &r = (double)ival;                 ❌ - ERROR 

    4* Bir referans bir nesneye baglanir, sonrasinda baska bir nesneye baglanamaz(Pointer Ref haric). Yani gosterdigi adres sonradan degistirilemez(const* ptr gibi)
    -> int x     = 10;
       int &r    = x + 10;                       ❌ - ERROR
       double &r = (double)ival;                 ❌ - ERROR

    5* Bir pointer kendisine referans alabilir.
    -> int x     = 10;           (int x)
       int *ptr  = &x;           (int * ptr)  = (int *)x 
       int *&rp  = ptr;          (int * &rp)  = ptr
                   
    6* Bir dizi kendisine referans alabilir.
    -> int a[5]      = {0,1,2,3,4};  
       int (&ra)[5]  = a;           
                        
    7* Referans kullaniminda pointerda oldugu gibi NULL pointer semantigi yoktur.

    8* Elemanlari referans olan bir referans dizisi olamaz.

    9* "Tur &func(...)" prototipindeki bir fonksiyona "func() = ..." seklinde yapilan cagri ifadesi "lvalue expression" sol deger 
        ifadesidir. Bu sayede deger atanabilmektedir.
        func(...) fonksiyonu nesneyi referans olarak doner. Bu yuzden referansa ilk deger vermede de kullanılabilmektedir.
        
        -> func() = 10;
        -> Tur &r = func();
    
    10* Referans ile pointer kullanmak assembly kod acisindan neredeyse aynidir. Derleyici icin neredeyse bir fark yoktur.
    
    11* Referanslarda null durumu yoktur.
 
    12* Elemanları nesne referansı(adresi) olan pointer dizisi olabilirken, referans dizisi
 
 
    ---------------------------------------------------- R E F E R A N C E  ve  C O N S T ---------------------------------------
    

    1* Referance'lardki "Tur * const ptr" karsiligi      ❌  (tur * const ptr)
    -> int x = 10;
       int &const r = x;
       Bu kullanim dogru bir kullanim degildir. Cunku referanslarin gosterdigi nesne zaten degistirilemez, baska bir nesnenin yerine gecemez. 
       Dogustan kenidisi const'tur.
       Derleyici Syntax hatasi vermeyebilir fakat uyari verir. 

    2* Referance'lardki "const Tur *ptr" karsiligi        ✔  (const tur *ptr)
    -> int x = 10;
       const int &r = x;
    -> const Tur *foo(...)
       Bu kullanimla birlikte r'nin gosterdigi x yalnizca salt okunabilir olarak kullanilabilinecektir. x'in degeri degistirilemez.




    ---------------------------------------------------- N U L L ----------------------------------------------------------------
    C'de "NULL"  bir makrodur. Tanimi;
    #define NULL (void *)0
    -> int *ptr = NULL;
       ptr = 0;
    C++'de nullptr vardır.  nullptr bir sabittir ve bir turu vardır. Bu turun ismi nullptr_t'dir.
    typedef decltype(nullptr) nullptr_t; 
    -> int *ptr = nullptr_t;
 
    Referanslarda null durumu yoktur.


******************************************************************************************************************************************/

/* Const Referans
 *************************************
 
 Referans tanımlamanırken normalde sabit bir değer atanamaz, l-value bir nesne atanabilir. Fakat const referans nesnelere sabit değerlerin atanması da geçerlidir.
 
 -> const int &cr1 = 10;
 bildirisinde derleyici tarafından geçici bir
 nesne oluşturulur ve const kabul edilir. Bu yüzden bu ifade geçerlidir.
 *************************************
*/
 #include <iostream>


 void func(const int &cr2)
 {
     
 }


 int main()
 {
           int &r1  = 10;      // Bu ifade geçersizdir ❌
     func(r1);
     
     const int &cr1 = 10;      // Bu ifade geçerlidir ✅
     func(cr1);
     

 }



// AUTO --------------------------------------------------------------------------------

#include <iostream>


double foo(){
    return 1.0;
};
int boo(int){
    return 10;
};


int main()
{
    // int h = 20
    const int cx = 20;
    auto h = cx;       // int h = 20
    
    // int y
    int  x = 10;
    auto y = x;
    
    // double z
    auto z = foo();
    
    // int q = 0;
    auto q = 0;
    
    // int a, referanslık düşer
    {
        int xx = 10;
        int &rx = x;
        auto a = rx;
    }
    
    // int a, referanslık ve constluk  düşer
    {
        int xx = 10;
        const int &rx = x;
        auto a = rx;
    }
    
    // int *ax = a
    {
        int a[10];
        auto ax = a;
    }
    
    //  const int *ax = a, tur cikarimi yapilirken const a, array to pointer conversion ile array decay ile const int* turune donusecektir.
    {
        const int a[] = {1,2,3};
        auto ax = a;
    }
    
    //  int(*fp)(int) , function pointer
    {
        auto f = boo;
    }

    //  int &r = x, auto referans
    {
        int  x  = 10;
        auto &r = x;
    }
    
    //  const int &r = x, constluk dusmez
    {
        const int  cx  = 10;
        auto &r = cx;
    }
    
    //  int (&r)[3] = x, constluk dusmez
    {
        int a[3] = {1,2,3};
        auto &r = a;
    }
    
    
}

/* Type Deduction - Tur Cikarimi
 *************************************
 
 AAA(Almost Always auto)
 - auto ile yaratılan nesnenin ilk değer ataması zorunludur.
 - auto ilk değer atamasinda {} ifadesini kullanmak sorun olabilir.
 
 Reference collapsing:
 Eger icerisinde bir tane bile sol taraf referansı(&) varsa sol taraf referansına, yoksa sağ taraf(&&) referansına bağlanır
 - int &   &r   -> int  &r
 - int &   &&r  -> int  &r
 - int &&   &r  -> int  &r
 - int &&  &&r  -> int &&r
 *************************************
 */



// CONSTEXPR --------------------------------------------------------------------------------
